//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//АДРЕС ЗАГРУЗЧИКА ПРОПИСЫВАЕТСЯ В MAKEFILE! (ПРОГРАММАТОР khazama ДАЁТ АДРЕС В СЛОВАХ! НАДО УМНОЖИТЬ НА 2!)
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//Загрузчик проверяет состояние PB1. Если там высокий уровень, то возможно обновление прошивки

//----------------------------------------------------------------------------------------------------
//частота контроллера
//----------------------------------------------------------------------------------------------------
#define F_CPU 8000000UL

#define bool unsigned char
#define true  1
#define false 0

//----------------------------------------------------------------------------------------------------
//библиотеки
//----------------------------------------------------------------------------------------------------
#include <avr/io.h>
#include <util/delay.h>
#include <string.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include <avr/boot.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//скорость передачи данных UART, бит/с
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#define UART_SPEED 19200UL

#define BOOTSIZE 1024
#define APP_END (FLASHEND - (BOOTSIZE * 2))

//----------------------------------------------------------------------------------------------------
//глобальные переменные
//----------------------------------------------------------------------------------------------------
unsigned char Buffer[128]; //буфер принятых команд или данных
unsigned short Addr = 0;
char CommandName[3][15]; //имена команд
//----------------------------------------------------------------------------------------------------
//прототипы функций
//----------------------------------------------------------------------------------------------------
void InitAVR(void); //инициализация контроллера
void EraseFlash(void); //стирание памяти микроконтроллера (до области загрузчика)

void ExecuteCommand(unsigned char *CommandPtr, int Length); //выполнить команду

static void (*jump_to_app)(void)=0x0000;
//----------------------------------------------------------------------------------------------------
//библиотеки
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
//основная функция программы
//----------------------------------------------------------------------------------------------------
int _main(void) {
	unsigned char n;
	DDRB = (0 << 7) | (0 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2)
			| (0 << 1) | (0 << 0);
	PORTB = 0xff;
	//анализируем состояние порта
	if (!(PINB & (1 << 1)))
		jump_to_app(); //передаём управление прошивке
	InitAVR();
	//задаём команды
	strcpy(CommandName[0], "SET ADDR");
	strcpy(CommandName[1], "WRITE");
	strcpy(CommandName[2], "ERASE");
	//переходим в режим программирования
	while (1) {
		if (!(UCSRA & (1 << RXC)))
			continue; //ждём байта данных с COM-порта
		unsigned char byte = UDR;
		//сдвигаем
		for (n = 0; n < 127; n++)
			Buffer[n] = Buffer[n + 1];
		Buffer[127] = byte;
		//ищем конец пакета
		if (Buffer[127] == (unsigned char) ('*')
				&& Buffer[126] == (unsigned char) (']')) //обнаружен конец пакета
						{
			//в конце пакета находятся два байта CRC
			unsigned short CRC_P = Buffer[124];
			CRC_P = CRC_P << 8;
			CRC_P |= Buffer[125];
			//ищем начало пакета и считаем CRC
			unsigned short CRC = 0; //контрольная сумма
			for (n = 123; n > 0; n--) {
				if (Buffer[n] == (unsigned char) ('[')
						&& Buffer[n - 1] == (unsigned char) ('*')) //найдено начало пакета
								{
					if (CRC == CRC_P) //мы нашли начало пакета
							{
						ExecuteCommand(Buffer + n + 1, 123 - n); //выполняем команду
						//очищаем буфер
						for (n = 0; n < 128; n++)
							Buffer[n] = 0;
						break;
					}
					//это ещё не начало пакета, или в пакете сбой
				}
				unsigned short b = Buffer[n];
				CRC ^= (b << 8);
				CRC = CRC << 1;
			}
		}
	}
	return (0);
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//общие функции
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//----------------------------------------------------------------------------------------------------
//инициализация контроллера
//----------------------------------------------------------------------------------------------------
void InitAVR(void) {
	//настраиваем порты
	DDRB = (0 << 7) | (0 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2)
			| (0 << 1) | (0 << 0);
	DDRD = (0 << 7) | (0 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2)
			| (0 << 1) | (0 << 0);
	DDRC = (0 << 7) | (0 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2)
			| (0 << 1) | (0 << 0);
	//задаём состояние портов
	PORTB = 0xff;
	PORTD = 0xff;
	PORTC = 0xff;
	//настраиваем UART
	//устанавливаем режим передачи данных
	UCSRB = (1 << RXEN) | (1 << TXEN);
	//RXCIE=1 и прерывания разрешены (бит I=1 в регистре SREG) : прерывание по завершению приёма по UART разрешено
	//TXCIE=1 и прерывания разрешены (бит I=1 в регистре SREG) : прерывание по завершению передачи по UART разрешено
	//UDRIE=1 и прерывания разрешены (бит I=1 в регистре SREG) : прерывание по опустошению регистра данных UART разрешено
	//RXEN=1 : активация приёмника, вывод D0 становится входом UART.
	//TXEN=1 : активация передатчика, вывод D1 становится выходом UART.
	//CHR9=1 : длина передаваемой посылки с становится равной 11 бит (9 бит данных + старт-стоповый бит + стоп-бит).
	//RXB8-расширенный стоп-бит
	//TXB8-расширенный стоп-бит
	//вычисляем значение регистра скорости передачи данных
	unsigned long speed = F_CPU / (16UL);
	speed = (speed / UART_SPEED) - 1UL;
	UBRRH = (speed >> 8) & 0xff;
	UBRRL = speed & 0xFF;
}
//----------------------------------------------------------------------------------------------------
//стирание памяти микроконтроллера (до области загрузчика)
//----------------------------------------------------------------------------------------------------
void EraseFlash(void) {
	uint32_t addr = 0;
	while (APP_END > addr) {
		boot_page_erase(addr);
		//производим стирание страницы
		boot_spm_busy_wait(); //ждём, когда страница сотрётся
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
}
//----------------------------------------------------------------------------------------------------
//обработка команд
//----------------------------------------------------------------------------------------------------
void ExecuteCommand(unsigned char *CommandPtr, int Length) {
	unsigned char n, m;
	//анализируем команду
	char CommandID = -1; //номер команды
	unsigned char CommandLength = 0; //длина имени команды
	for (n = 0; n < 3; n++) {
		unsigned char l = strlen(CommandName[n]);
		if (Length < l)
			continue; //слишком мало байт пришло
		for (m = 0; m < l; m++) {
			if ((unsigned char) (CommandName[n][m]) != CommandPtr[m])
				break;
		}
		if (m == l) {
			CommandID = n;
			CommandLength = l;
			break;
		}
	}
	bool CommandIsDone = false; //команда не выполнена
	if (CommandID == 0) //команда SET ADDR
			{
		if (Length >= CommandLength + 2) {
			CommandIsDone = true;
			//запоминаем адрес
			Addr = CommandPtr[CommandLength];
			Addr = Addr << 8;
			Addr |= CommandPtr[CommandLength + 1];
		}
	}
	if (CommandID == 1) //команда WRITE
			{
		unsigned char l = Length - CommandLength;
		unsigned short StartAddr = Addr;
		for (n = 0; n < l; n += 2) {
			unsigned char l = CommandPtr[n + CommandLength];
			unsigned char h = CommandPtr[n + CommandLength + 1];
			unsigned short word = h;
			word = word << 8;
			word |= l;
			boot_page_fill(Addr, word);
			//записываем
			Addr += 2;
		}
		boot_page_write(StartAddr);
		boot_spm_busy_wait();
		boot_rww_enable();
		CommandIsDone = true;
	}
	if (CommandID == 2) //команда ERASE
			{
		EraseFlash();
		CommandIsDone = true;
	}
	if (CommandIsDone == true) {
		//отправляем ответ
		char string[7] = "CMD OK";
		//передаём
		for (unsigned char n = 0; n < 7; n++) {
			while (!(UCSRA & (1 << UDRE)))
				;
			UDR = string[n];
		}
	}
}
