/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
//  LOOKAHEAD=2;

  static = false;
}

PARSER_BEGIN(EG1)
package kvv.evlang;
import java.io.*;
import java.util.*;
import kvv.evlang.impl.*;
import kvv.evlang.impl.LocalListDef.Local;
import kvv.controllers.register.*;

public abstract class EG1 extends EG
{
  public EG1(String fileName) throws FileNotFoundException
  {
	//this(new InputStreamReader(new FileInputStream(fileName), "Windows-1251"));
//    this (new FileReader(fileName));
    this (new JavaCCReader(fileName));
  }

  public void throwExc(String msg) throws ParseException
  {
	throw new ParseException(token, msg);
  }

  public void parse() throws ParseException
  {
    file();
    buildInit();
    check();
    //checkStack();
  }
}

PARSER_END(EG1)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

TOKEN : /* OPERATORS */
{
  < AND : "&&" >
| < OR : "||" >
| < EQ : "==" >
| < NEQ : "!=" >
| < LT : "<" >
| < LE : "<=" >
| < GT : ">" >
| < GE : ">=" >
| < NOT : "!" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < EEPROM : "eeprom" >
| < REG : "reg" >
| < EEREG : "eereg" >
| < TIMER : "timer" >
| < ONSET : "onset" >
| < ONCHANGE : "onchange" >
| < CONST : "const" >
| < IF : "if" >
| < ELSE : "else" >
| < START_S : "start_s" >
| < START_MS : "start_ms" >
| < STOP : "stop" >
| < PRINT : "print" >
| < DEC : "--" >
| < INC : "++" >
| < MULDIV : "muldiv" >
| < CHECKBOX : "checkbox" >
| < TEXT : "text" >
| < INT : "int" >
| < VOID : "void" >
| < RETURN : "return" >
| < TRY  : "try" > 
| < CATCH  : "catch" >
| < THROW  : "throw" >
| < STRUCT  : "struct" >
| < NULL  : "null" >
| < NEW  : "new" >
| < XTIMER  : "xtimer" >
}

TOKEN :
{
  < ID : [ "a"-"z", "A"-"Z", "_", "\u00A0"-"\u00FF" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9", "\u00A0"-"\u00FF" ])* >
| < STRING : "\"" (~[ "\"", "\n", "\r" ])* "\"" >
| < NUMBER : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}

void file() :
{}
{
  < EOF >
| line() file()
}

void line() :
{}
{
  constant()
| register()
| varOrProc()
| uiDecl()
| timer()
| xtimer()
| onset()
| onchange()
| struct()
}

void varOrProc() :
{
  Type type;
  String name;
}
{
  type = type() name = id()
  (
    proc(type, name, null)
  |
  	var(type, name)
  ) 
}
  


void struct() :{  String name;  String fieldName;  Type fieldType;  Struct struct;}{  < STRUCT > name = id()  {    struct = createStruct(name, false);  }  "{"  (    fieldType = type() fieldName = id()    (      proc(fieldType, fieldName, struct)    | ";"      {        checkNotVoid(fieldType);        addField(struct, fieldType, fieldName);      }    )  )*  "}"}

Type type() :{  String name = null;}{  < VOID >  {    return Type.VOID;  }|   < INT >
  {
    return Type.INT;
  }
| 
  name = id()  {    return new Type(name);  }}


void proc(Type type, String name, Struct thisType) :{  Code bytes = null;  LocalListDef locals = new LocalListDef();  if (thisType != null)  {    locals.add(new NameAndType("this", thisType.type));    name = thisType.type.name + ":" + name;  }}{  "(" [ argListDef(locals) ] ")"  {    locals.endOfArgs();
    Code.procDecl(this, type, name, locals);  }  (    bytes = stmtBlock()    {      Code.procCode(this, bytes);    }  | ";"  )}

void argListDef(LocalListDef locals) :
{
}
{
  localDef(locals)
  (
    "," localDef(locals)
  )*
  {
    locals.endOfArgs();
  }
}

Local localDef(LocalListDef locals) :
{
  String name;
  Type type;
}
{
    type = type() name = id()
    {
      checkNotVoid(type);
      return locals.add(new NameAndType(name, type));
    }
}


void constant() :
{
  String name;
  short value;
}
{
  < CONST > name = id() "=" value = number() ";"
  {
    checkName(name);
    constants.put(name, value);
  }
}

void uiDecl() :
{
  String name;
  Token text;
  RegType type;
}
{
  type = uitype() name = id() text = < STRING > ";"
  {
    setUI(name, text.image.replace("\"", ""), type);
  }
}

RegType uitype() :
{
  Token t;
}
{
  t = < CHECKBOX >
  {
    return RegType.checkbox;
  }
| t = < TEXT >
  {
    return RegType.textRW;
  }
}

void var(Type type, String name) :
{
  Expr e = null;
}
{
  [ "=" e = expr() ]
  ";"
  {
	 checkNotVoid(type);
	 newVar(type, name, e);
  }
}

void register() :
{
  String regName;
  String regNum = null;
  short initVal;
}
{
  < REG > regName = id() "(" regNum = id() ")" ";"
  {
    newRegisterAlias(regName, regNum);
  }
|  < EEREG > regName = id() "=" initVal = number() ";"
  {
    newEERegister(regName, initVal);
  }
}

void xtimer() :{  String name;  String fieldName;  Type fieldType;  Code code;  Struct struct;}{  < XTIMER > name = id()  {    LocalListDef locals = new LocalListDef();    locals.add(new NameAndType("this", new Type(name)));    Func func = Code.procDecl(this, Type.VOID, "__timer__" + name,     locals);    struct = createXTimer(name);
    struct.timerFunc = func.n;  }  "{"  (    fieldType = type() fieldName = id() ";"    {      checkNotVoid(fieldType);      addField(struct, fieldType, fieldName);    }  )*  code = stmtBlock()  {    Code.procCode(this, code);  }  "}"}

void timer() :
{
  String name;
  Code bytes;
}
{
  {
    currentFunc = new Func(this, "", new LocalListDef(), Type.VOID);
  }
  < TIMER > name = id() bytes = stmtBlock()
  {
    Code.timer(this, name, bytes);
  }
}

void onset() :
{
  Expr cond;
  Code bytes;
}
{
  {
    currentFunc = new Func(this, "", new LocalListDef(), Type.VOID);
  }
  < ONSET > "(" cond = expr() ")" bytes = stmtBlock()
  {
    Code.onset(this, cond.getCode(), bytes);
  }
}

void onchange() :
{
  Expr cond;
  Code bytes;
}
{
  {
    currentFunc = new Func(this, "", new LocalListDef(), Type.VOID);
  }
  < ONCHANGE > "(" cond = expr() ")" bytes = stmtBlock()
  {
    Code.onchange(this, cond.getCode(), bytes);
  }
}

Code stmtBlock() :
{
  Code bytes = new Code(this);
  Code temp;
  int localpos = currentFunc.locals.getSize();
}
{
  "{"
  (
    temp = stmt()
    {
      bytes.addAll(temp);
    }
  )*
  "}"
  {
    currentFunc.locals.setSize(localpos);
    return bytes;
  }
}

Code stmt() :{  Code res;}{  (    LOOKAHEAD(2)    res = assign()  | res = ifStmt()  | res = tryCatchStmt()  | res = stmtBlock()  )  {    return res;  }}

Code tryCatchStmt() :
{
  Code tryStmt;
  Code catchStmt;
  Local local;
}
{
  < TRY > tryStmt = stmtBlock() < CATCH > "(" local = localDef(currentFunc.locals) ")" catchStmt = stmtBlock()
  {
    return Code.trycatchstmt(this, tryStmt, catchStmt, local);
  }
}

Code ifStmt() :
{
  Expr res;
  Code stmt;
  Code stmt2 = null;
}
{
  < IF > "(" res = expr() ")" stmt = stmt()
  [
    LOOKAHEAD(2)
    < ELSE > stmt2 = stmt()
  ]
  {
    return Code.ifstmt(res, stmt, stmt2);
  }
}

Code assign() :
{
  Expr res = null;
  LValue lvalue;
  String name;
  List < Expr > argList = new ArrayList < Expr > ();
  Local local;
}
{
  < PRINT > res = expr() ";"
  {
    return Code.print(res);
  }
| < RETURN > [ res = expr() ] ";"
  {
    return Code.ret(this, res);
  }
| < THROW > [ res = expr() ] ";"
  {
    return Code.throw_(this, res);
  }
| < START_S > "(" name = id() "," res = expr() ")" ";"
  {
    return Code.start_s(this, name, res);
  }
| < START_MS > "(" name = id() "," res = expr() ")" ";"
  {
    return Code.start_ms(this, name, res);
  }
| < STOP > "(" name = id() ")" ";"
  {
    return Code.stop(this, name);
  }
|
    LOOKAHEAD(2)
	local = localDef(currentFunc.locals) "=" res = expr() ";"
  {
    return Code.initLocal(this, local, res);
  }
| lvalue = lvalue1()
  [
    "=" res = expr() 
  ]   ";"
  {
    return Code.assign(this, lvalue, res);
  }
}

Expr expr() :
{
  List < Expr > res = new ArrayList < Expr > ();
  Expr temp;
}
{
  temp = logAndExpr()
  {
    res.add(temp);
  }
  (
    < OR > temp = logAndExpr()
    {
      res.add(temp);
    }
  )*
  {
    return Expr.or(this, res);
  }
}

Expr logAndExpr() :
{
  List < Expr > res = new ArrayList < Expr > ();
  Expr temp;
}
{
  temp = boolExpr()
  {
    res.add(temp);
  }
  (
    < AND > temp = boolExpr()
    {
      res.add(temp);
    }
  )*
  {
    return Expr.and(this, res);
  }
}

Expr boolExpr() :
{
  Expr res;
  Expr temp;
}
{
  res = intExpr()
  (
    (
      < EQ > temp = intExpr()
      {
        res = Expr.eq(this, res, temp);
      }
    | < NEQ > temp = intExpr()
      {
        res = Expr.neq(this,res, temp);
      }
    | < LT > temp = intExpr()
      {
        res = Expr.lt(this,res, temp);
      }
    | < LE > temp = intExpr()
      {
        res = Expr.le(this,res, temp);
      }
    | < GT > temp = intExpr()
      {
        res = Expr.gt(this,res, temp);
      }
    | < GE > temp = intExpr()
      {
        res = Expr.ge(this,res, temp);
      }
    )
  )*
  {
    return res;
  }
}

Expr intExpr() :
{
  Expr res;
  Expr temp;
}
{
  res = term()
  (
    (
      < PLUS > temp = term()
      {
        res = Expr.add(this,res, temp);
      }
    | < MINUS > temp = term()
      {
        res = Expr.sub(this,res, temp);
      }
    )
  )*
  {
    return res;
  }
}

Expr term() :
{
  Expr res;
  Expr temp;
}
{
  res = unary()
  (
    (
      < MULTIPLY > temp = unary()
      {
        res = Expr.mul(this, res, temp);
      }
    | < DIVIDE > temp = unary()
      {
        res = Expr.div(this, res, temp);
      }
    )
  )*
  {
    return res;
  }
}

Expr unary() :
{
  Expr res;
}
{
  < NOT > res = element()
  {
    return Expr.not(this, res);
  }
| < MINUS > res = element()
  {
    return Expr.negate(this, res);
  }
| res = element()
  {
    return res;
  }
}

Expr element() :{  Expr res;  LValue lvalue;}{  res = simpleElement()  {    return res;  }| lvalue = lvalue1()  {    return lvalue.getExpr();  }}

LValue lvalue1() :{  LValue res;  Expr expr;}{  (    res = field(null)  | expr = newExpr()    {      res = new LValue(this, expr);    }  )  (    "." res = field(res)  )*  {    return res;  }}

LValue field(LValue left) :
{
  String name;
  List < Expr > argList = null;
}
{
  name = id()
  [
    "("
    {
      argList = new ArrayList < Expr > ();
    }
    [ argList = argList() ] ")"
  ]
  {
    return new LValue(this, left, name, argList);
  }
}


Expr simpleElement() :
{
  short n;
  String name;
  List < Expr > argList = null;
  Expr res;
}
{
  < NULL >
  {
    return Expr.nullExpr(this);
  }
| n = number()
  {
    return new Expr(this, n);
  }
| res = muldiv()
  {
    return res;
  }
| "(" res = expr() ")"
  {
    return res;
  }
}



Expr muldiv():{  Expr res;
  Expr temp;
  Expr temp1;
}{  < MULDIV > "(" res = expr() "," temp = expr() "," temp1 = expr() ")"
  {
    return Expr.muldiv(this, res, temp, temp1);
  }
}

Expr newExpr():{  String name;
  List < Expr > argList = null;
}{
  < NEW > name = id() 
  "("
  {
    argList = new ArrayList < Expr > ();
  }
  [ argList = argList() ] ")"
  {
    return Expr.newObj(this, name, argList);
  }}
  

String id() :
{
  Token t;
}
{
  t = < ID >
  {
    return win2utf(t.image);
  }
}

short number() :
{
  Token t;
}
{
  t = < NUMBER >
  {
    return Short.parseShort(t.image);
  }
}

List < Expr > argList() :
{
  List < Expr > res = new ArrayList < Expr > ();
  Expr arg;
}
{
  arg = expr()
  {
    res.add(arg);
  }
  (
    "," arg = expr()
    {
      res.add(arg);
    }
  )*
  {
    return res;
  }
}


