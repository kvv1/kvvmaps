/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(EG1)package kvv.evlang;import java.io.*;import java.util.*;import kvv.evlang.impl.*;import kvv.controllers.register.*;public abstract class EG1 extends EG{  public EG1(String fileName) throws FileNotFoundException  {    this (new JavaCCReader(fileName));  }  public void parse() throws ParseException  {    file();    buildInit();    check();    checkStack();  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* OPERATORS */{  < AND : "&&" >| < OR : "||" >| < EQ : "==" >| < NEQ : "!=" >| < LT : "<" >| < LE : "<=" >| < GT : ">" >| < GE : ">=" >| < NOT : "!" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < EEPROM : "eeprom" >| < REG : "reg" >| < EXTREG : "extreg" >| < EEREG : "eereg" >| < TIMER : "timer" >| < ONSET : "onset" >| < ONCHANGE : "onchange" >| < CONST : "const" >| < IF : "if" >| < ELSE : "else" >| < START_S : "start_s" >| < START_MS : "start_ms" >| < STOP : "stop" >| < PRINT : "print" >| < DEC : "--" >| < INC : "++" >| < MULDIV : "muldiv" >| < CHECKBOX : "checkbox" >| < TEXT : "text" >| < INT : "int" >| < VOID : "void" >| < RETURN : "return" >}TOKEN :{  < ID : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >| < STRING : "\"" (~[ "\"", "\n", "\r" ])* "\"" >| < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}void file() :{}{  < EOF >| line() file()}void line() :{}{  constant()| register()| uiDecl()| timer()| onset()| onchange()| proc()}void proc() :{  Token name;  Code bytes = null;  int retSize = 0;  LocalListDef locals = new LocalListDef();}{  (    < VOID >  | < INT >    {      retSize = 1;      ;    }  )  name = < ID > "(" [ argListDef(locals) ] ")"  {    Code.procDecl(this, retSize, name.image, locals);  }  (    bytes = stmtBlock()    {      Code.procCode(this, bytes);    }  | ";"  )}void argListDef(LocalListDef locals) :{  Token arg;}{  < INT > arg = < ID >  {    locals.add(arg.image);  }  (    "," < INT > arg = < ID >    {      locals.add(arg.image);    }  )*  {    locals.endOfArgs();  }}void localListDef() :{  Token arg;}{  (    < INT > arg = < ID > ";"    {      currentFunc.locals.add(arg.image);    }  )*}void constant() :{  Token name;  Token value;}{  < CONST > name = < ID > "=" value = < NUMBER > ";"  {    checkName(name.image);    constants.put(name.image, Short.parseShort(value.image));  }}void uiDecl() :{  Token name;  Token text;  RegType type;}{  type = uitype() name = < ID > text = < STRING > ";"  {    setUI(name.image, text.image.replace("\"", ""), type);  }}RegType uitype() :{  Token t;}{  t = < CHECKBOX >  {    return RegType.checkbox;  }| t = < TEXT >  {    return RegType.textRW;  }}void register() :{  Token regName;  Token regNum = null;  Token extRegName = null;  Token initVal = null;}{  < EXTREG > extRegName = < ID > ";"  {    newExtRegister(extRegName.image);  }| < REG > regName = < ID > [ "(" regNum = < ID > ")" ] ";"  {    if (regNum == null) newRegister(regName.image);    else newRegister(regName.image, regNum.image);  }| < EEREG > regName = < ID > "=" initVal = < NUMBER > ";"  {    newEERegister(regName.image, Short.parseShort(initVal.image));  }}void timer() :{  Token name;  Code bytes;}{  {    currentFunc = new Func(this, "", new LocalListDef(), 0);  }  < TIMER > name = < ID > bytes = stmtBlock()  {    Code.timer(this, name.image, bytes);  }}void onset() :{  Expr cond;  Code bytes;}{  {    currentFunc = new Func(this, "", new LocalListDef(), 0);  }  < ONSET > "(" cond = expr() ")" bytes = stmtBlock()  {    Code.onset(this, cond.getCode(), bytes);  }}void onchange() :{  Expr cond;  Code bytes;}{  {    currentFunc = new Func(this, "", new LocalListDef(), 0);  }  < ONCHANGE > "(" cond = expr() ")" bytes = stmtBlock()  {    Code.onchange(this, cond.getCode(), bytes);  }}Code stmtBlock() :{  Code bytes = new Code();  Code temp;  int localpos = currentFunc.locals.getSize();}{  "{" localListDef()  (    temp = stmt()    {      bytes.addAll(temp);    }  )*  "}"  {    currentFunc.locals.setSize(localpos);    return bytes;  }}Code stmt() :{  Code res;  Token name;}{  res = assign()  {    return res;  }| res = ifStmt()  {    return res;  }| res = stmtBlock()  {    return res;  }}Code ifStmt() :{  Expr res;  Code stmt;  Code stmt2 = null;}{  < IF > "(" res = expr() ")" stmt = stmt()  [    LOOKAHEAD(2)    < ELSE > stmt2 = stmt()  ]  {    return Code.ifstmt(res, stmt, stmt2);  }}Code assign() :{  Expr res = null;  Token name;  List < Expr > argList = new ArrayList < Expr > ();}{  < PRINT > res = expr() ";"  {    return Code.print(res);  }| < RETURN > [ res = expr() ] ";"  {    return Code.ret(this, res);  }| name = < ID >  (    "=" res = expr() ";"    {      return Code.assign(this, name.image, res);    }  | "."    (      < START_S > res = expr() ";"      {        return Code.start_s(this, name.image, res);      }    | < START_MS > res = expr() ";"      {        return Code.start_ms(this, name.image, res);      }    | < STOP > ";"      {        return Code.stop(this, name.image);      }    )  | < DEC > ";"    {      return Code.dec(this, name.image);    }  | < INC > ";"    {      return Code.inc(this, name.image);    }  | "(" [ argList = argList() ] ")" ";"    {      return Code.callp(this, name.image, argList);    }  )}Expr expr() :{  Expr res;  Expr temp;}{  res = logAndExpr()  (    < OR > temp = logAndExpr()    {      res = Expr.or(res, temp);    }  )*  {    return res;  }}Expr logAndExpr() :{  Expr res;  Expr temp;}{  res = boolExpr()  (    < AND > temp = boolExpr()    {      res = Expr.and(res, temp);    }  )*  {    return res;  }}Expr boolExpr() :{  Expr res;  Expr temp;}{  res = intExpr()  (    (      < EQ > temp = intExpr()      {        res = Expr.eq(res, temp);      }    | < NEQ > temp = intExpr()      {        res = Expr.neq(res, temp);      }    | < LT > temp = intExpr()      {        res = Expr.lt(res, temp);      }    | < LE > temp = intExpr()      {        res = Expr.le(res, temp);      }    | < GT > temp = intExpr()      {        res = Expr.gt(res, temp);      }    | < GE > temp = intExpr()      {        res = Expr.ge(res, temp);      }    )  )*  {    return res;  }}Expr intExpr() :{  Expr res;  Expr temp;}{  res = term()  (    (      < PLUS > temp = term()      {        res = Expr.add(res, temp);      }    | < MINUS > temp = term()      {        res = Expr.sub(res, temp);      }    )  )*  {    return res;  }}Expr term() :{  Expr res;  Expr temp;}{  res = unary()  (    (      < MULTIPLY > temp = unary()      {        res = Expr.mul(res, temp);      }    | < DIVIDE > temp = unary()      {        res = Expr.div(res, temp);      }    )  )*  {    return res;  }}Expr unary() :{  Expr res;}{  < NOT > res = element()  {    return Expr.not(res);  }| < MINUS > res = element()  {    return Expr.negate(res);  }| res = element()  {    return res;  }}List < Expr > argList() :{  List < Expr > res = new ArrayList < Expr > ();  Expr arg;}{  arg = expr()  {    res.add(arg);  }  (    "," arg = expr()    {      res.add(arg);    }  )*  {    return res;  }}Expr element() :{  Token t;  List < Expr > argList = null;}{  t = < NUMBER >  {    return new Expr(Short.parseShort(t.image));  }| t = < ID >  (    "("    {      argList = new ArrayList < Expr > ();    }    [ argList = argList() ] ")"  )?  {    if (argList != null)    {      return new Expr(this, t.image, argList);    }    else    {      return new Expr(this, t.image);    }  }|  {    Expr res;    Expr temp;    Expr temp1;  }  < MULDIV > "(" res = expr() "," temp = expr() "," temp1 = expr() ")"  {    return Expr.muldiv(res, temp, temp1);  }| "(" res = expr() ")"  {    return res;  }}
