/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(EG1)package kvv.evlang;import java.io.*;import java.util.*;import kvv.evlang.impl.*;import kvv.evlang.rt.*;import kvv.evlang.impl.Context;import kvv.controllers.register.*;public class EG1 extends EG{  public void parse() throws ParseException  {    file();    check();    checkStack();  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| "\n"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* OPERATORS */{  < AND : "&&" >| < OR : "||" >| < EQ : "==" >| < NEQ : "!=" >| < LT : "<" >| < LE : "<=" >| < GT : ">" >| < GE : ">=" >| < NOT : "!" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < EEPROM : "eeprom" >| < REG : "reg" >| < EEREG : "eereg" >| < TIMER : "timer" >| < ONSET : "onset" >| < ONCHANGE : "onchange" >| < CONST : "const" >| < IF : "if" >| < ELSE : "else" >| < START_S : "start_s" >| < START_MS : "start_ms" >| < STOP : "stop" >| < MAIN : "main" >| < PRINT : "print" >| < DEC : "--" >| < INC : "++" >| < PROC : "proc" >| < FUNC : "func" >| < MULDIV : "muldiv" >| < CHECKBOX : "checkbox" >| < TEXT : "text" >}TOKEN :{  < ID : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >| < STRING : "\"" (~[ "\"", "\n", "\r" ])* "\"" >| < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}void file() :{}{  < EOF >| line() file()}void line() :{}{  constant()| register()| uiDecl()| timer()| onset()| onchange()| proc()| func()| main()}void proc() :{  Token name;  Code bytes;}{  < PROC > name = < ID > "(" [ args = argListDef() ] ")" bytes = stmtBlock()  {    if (args.getArgCnt() == 0) bytes.add(BC.RET);    else bytes.add(BC.RET_N);    bytes.add(args.getArgCnt());    Func func = getCreateFunc(name.image, args.getArgCnt(), false);    func.code = new CodeRef(bytes);    args.clear();    System.out.println("proc " + name.image + " " + bytes.size());  }}void func() :{  Token name;  Code bytes;}{  < FUNC > name = < ID > "(" [ args = argListDef() ] ")" "=" bytes = expr() ";"  {    if (args.getArgCnt() == 0) bytes.add(BC.RETI);    else bytes.add(BC.RETI_N);    bytes.add(args.getArgCnt());    Func func = getCreateFunc(name.image, args.getArgCnt(), true);    func.code = new CodeRef(bytes);    args.clear();    System.out.println("func " + name.image + " " + bytes.size());  }}ArgListDef argListDef() :{  ArgListDef args = new ArgListDef();  Token arg;}{  arg = < ID >  {    args.add(arg.image);  }  (    "," arg = < ID >    {      args.add(arg.image);    }  )*  {    args.endOfArgs();    return args;  }}void main() :{  Code code;}{  < MAIN > code = stmtBlock()  {    code.add(BC.RET);    Func func = new Func("", 0, 0, false);    func.code = new CodeRef(code);    funcValues.set(0, func);    System.out.println("main " + code.size());  }}void constant() :{  Token name;  Token value;}{  < CONST > name = < ID > "=" value = < NUMBER > ";"  {    checkName(name.image);    constants.put(name.image, Integer.parseInt(value.image));  }}void uiDecl() :{  Token name;  Token text;  RegType type;}{  type = uitype() name = < ID > text = < STRING > ";"  {    setUI(name.image, text.image.replace("\"", ""), type);  }}RegType uitype() :{  Token t;}{  t = < CHECKBOX >  {    return RegType.checkbox;  }| t = < TEXT >  {    return RegType.textRW;  }}void register() :{  Token regName;  Token regNum = null;}{  < REG > regName = < ID > ("(" regNum = < ID > ")")? ";"  {    newRegister(regName, regNum, false);  }| < EEREG > regName = < ID > ";"  {    newRegister(regName, null, true);  }}void timer() :{  Token name;  Code bytes;}{  < TIMER > name = < ID > bytes = stmtBlock()  {    bytes.add(BC.RET);    Timer timer = getCreateTimer(name.image);    timer.handler = new CodeRef(bytes);    System.out.println("timer " + name.image + " " + bytes.size());  }}void onset() :{  Code cond;  Code bytes;}{  < ONSET > "(" cond = expr() ")" bytes = stmtBlock()  {    cond.add(BC.RETI);    bytes.add(BC.RET);    events.add(new Event(cond, bytes, EventType.SET));    System.out.println("onset " + cond.size() + " " + bytes.size());  }}void onchange() :{  Code cond;  Code bytes;}{  < ONCHANGE > "(" cond = expr() ")" bytes = stmtBlock()  {    cond.add(BC.RETI);    bytes.add(BC.RET);    events.add(new Event(cond, bytes, EventType.CHANGE));    System.out.println("onchange " + cond.size() + " " + bytes.size());  }}Code stmtBlock() :{  Code bytes = new Code();  Code temp;}{  "{"  (    temp = stmt()    {      bytes.addAll(temp);    }  )*  "}"  {    return bytes;  }}Code stmt() :{  Code res;  Token name;}{  res = assign()  {    return res;  }| res = ifStmt()  {    return res;  }| res = stmtBlock()  {    return res;  }| < PRINT > res = expr() ";"  {    res.add(BC.PRINT);    return res;  }}Code ifStmt() :{  Code res;  Code stmt;  Code stmt2 = null;}{  < IF > "(" res = expr() ")" stmt = stmt()  [    LOOKAHEAD(2)    < ELSE > stmt2 = stmt()  ]  {    if (stmt2 != null)    {      res.add(BC.QBRANCH);      res.add(stmt.size() + 2);      res.addAll(stmt);      res.add(BC.BRANCH);      res.add(stmt2.size());      res.addAll(stmt2);    }    else    {      res.add(BC.QBRANCH);      res.add(stmt.size());      res.addAll(stmt);    }    return res;  }}Code assign() :{  Code res;  Token name;  List < Code > argList = new ArrayList < Code > ();  Timer timer;}{  name = < ID >  (    "=" res = expr() ";"    {      Integer val = args.get(name.image);      if (val != null)      {        res.compileSetLocal(val - args.getArgCnt());      }      else      {        RegisterDescr descr = registers.get(name.image);        if (descr == null) throw new ParseException(name.image + " - ?");        checkROReg(descr);        res.compileSetreg(descr.reg);      }      return res;    }  | "."    (      < START_S > res = expr() ";"      {        timer = getCreateTimer(name.image);        res.add(BC.SETTIMER_S);        res.add(timer.n);        return res;      }    | < START_MS > res = expr() ";"      {        timer = getCreateTimer(name.image);        res.add(BC.SETTIMER_MS);        res.add(timer.n);        return res;      }    | < STOP > ";"      {        timer = getCreateTimer(name.image);        res = new Code();        res.add(BC.STOPTIMER);        res.add(timer.n);        return res;      }    )  | < DEC > ";"    {      RegisterDescr descr = registers.get(name.image);      if (descr == null) throw new ParseException(name.image + " - ?");      checkROReg(descr);      res = new Code();      res.add(BC.DEC);      res.add(descr.reg);      return res;    }  | < INC > ";"    {      descr = registers.get(name.image);      if (descr == null) throw new ParseException(name.image + " - ?");      checkROReg(descr);      res = new Code();      res.add(BC.INC);      res.add(descr.reg);      return res;    }  | "(" [ argList = argList() ] ")" ";"    {      Func func = getCreateFunc(name.image, argList.size(), false);      res = new Code();      for (Code c : argList) res.addAll(c);      res.add(BC.CALLP);      res.add(func.n);      return res;    }  )}Code expr() :{  Code res;  Code temp;}{  res = logAndExpr()  (    < OR > temp = logAndExpr()    {      res.addAll(temp);      res.add(BC.OR);    }  )*  {    return res;  }}Code logAndExpr() :{  Code res;  Code temp;}{  res = boolExpr()  (    < AND > temp = boolExpr()    {      res.addAll(temp);      res.add(BC.AND);    }  )*  {    return res;  }}Code boolExpr() :{  Code res;  Code temp;}{  res = intExpr()  (    (      < EQ > temp = intExpr()      {        res.addAll(temp);        res.add(BC.EQ);      }    | < NEQ > temp = intExpr()      {        res.addAll(temp);        res.add(BC.NEQ);      }    | < LT > temp = intExpr()      {        res.addAll(temp);        res.add(BC.LT);      }    | < LE > temp = intExpr()      {        res.addAll(temp);        res.add(BC.LE);      }    | < GT > temp = intExpr()      {        res.addAll(temp);        res.add(BC.GT);      }    | < GE > temp = intExpr()      {        res.addAll(temp);        res.add(BC.GE);      }    )  )*  {    return res;  }}Code intExpr() :{  Code res;  Code temp;}{  res = term()  (    (      < PLUS > temp = term()      {        res.addAll(temp);        res.add(BC.ADD);      }    | < MINUS > temp = term()      {        res.addAll(temp);        res.add(BC.SUB);      }    )  )*  {    return res;  }}Code term() :{  Code res;  Code temp;}{  res = unary()  (    (      < MULTIPLY > temp = unary()      {        res.addAll(temp);        res.add(BC.MUL);      }    | < DIVIDE > temp = unary()      {        res.addAll(temp);        res.add(BC.DIV);      }    )  )*  {    return res;  }}Code unary() :{  Code res;}{  < NOT > res = element()  {    res.add(BC.NOT);    return res;  }| < MINUS > res = element()  {    res.add(BC.NEGATE);    return res;  }| res = element()  {    return res;  }}List < Code > argList() :{  List < Code > res = new ArrayList < Code > ();  Code arg;}{  arg = expr()  {    res.add(arg);  }  (    "," arg = expr()    {      res.add(arg);    }  )*  {    return res;  }}Code element() :{  Token t;  Code res = new Code();  boolean call = false;  List < Code > argList = new ArrayList < Code > ();}{  t = < NUMBER >  {    res = new Code();    short s = Short.parseShort(t.image);    res.compileLit(s);    return res;  }| t = < ID >  (    "(" [ argList = argList() ] ")"    {      call = true;    }  )?  {    if (call)    {      Func func = getCreateFunc(t.image, argList.size(), true);      res = new Code();      for (Code c : argList) res.addAll(c);      res.add(BC.CALLF);      res.add(func.n);      return res;    }    else    {      res = new Code();      Integer val = args.get(t.image);      if (val != null)      {        res.compileGetLocal(val - args.getArgCnt());      }      else      {        RegisterDescr descr = registers.get(t.image);        if (descr != null)        {          res.compileGetreg(descr.reg);        }        else        {          val = constants.get(t.image);          if (val == null) throw new ParseException(t.image + " - ?");          res.compileLit((short) (int) val);        }      }      return res;    }  }|  {    Code temp;    Code temp1;  }  < MULDIV > "(" res = expr() "," temp = expr() "," temp1 = expr() ")"  {    res.addAll(temp);    res.addAll(temp1);    res.add(BC.MULDIV);    return res;  }| "(" res = expr() ")"  {    return res;  }}
